# binary searching

def binary_search(lst, item):
    low = 0       # Устанавливаем начальную нижнюю границу для поиска.
    high = len(lst) - 1  # Устанавливаем начальную верхнюю границу для поиска.

    while low <= high:  # Пока нижняя граница не станет больше верхней границы, продолжаем поиск.
        mid = (low + high) // 2   # Находим средний индекс списка.
        guess = lst[mid]   # Получаем значение элемента в середине списка.
        if guess == item:   # Если значение элемента равно искомому элементу, возвращаем индекс этого элемента.
            return mid
        if guess > item:    # Если значение элемента больше искомого элемента, устанавливаем новую верхнюю границу поиска.
            high = mid - 1
        else:    # Если значение элемента меньше искомого элемента, устанавливаем новую нижнюю границу поиска.
            low = mid + 1
    return None   # Если элемент не найден в списке, возвращаем None.


# Пример использования функции:
# lst = [1, 3, 5, 7, 9]
# result = binary_search(lst, 9)
# print(result)  # Выведет: 2 (так как элемент 5 находится в списке под индексом 2)
#
# Давайте рассмотрим, как работает функция binary_search для вашего примера, когда вы ищете элемент 9 в отсортированном списке lst = [1, 3, 5, 7, 9].
#
# Начальные значения:
# low = 0 (нижняя граница)
# high = 4 (верхняя граница)
#
# Вход в цикл while:
#
#     Итерация 1:
#     mid = (0 + 4) // 2 = 2 (средний индекс)
#     guess = lst[2] = 5
#     Так как guess (5) меньше item (9), мы обновляем low на mid + 1, теперь low = 3.
#
# Итерация 2:
# mid = (3 + 4) // 2 = 3
# guess = lst[3] = 7
# Так как guess (7) меньше item (9), мы обновляем low на mid + 1, теперь low = 4.
#
# Итерация 3:
# mid = (4 + 4) // 2 = 4
# guess = lst[4] = 9
# Теперь guess равен item, и мы нашли искомый элемент.
# Функция возвращает mid, который равен 4.
#
# Выход из цикла.
#
# Таким образом, функция завершает выполнение и возвращает индекс элемента 9, который равен 4.
#
# Как видите, бинарный поиск эффективно сокращает диапазон поиска вдвое на каждой итерации,
# что делает его очень быстрым для поиска элементов в больших отсортированных списках.
